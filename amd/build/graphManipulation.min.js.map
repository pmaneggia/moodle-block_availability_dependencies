{"version":3,"file":"graphManipulation.min.js","sources":["../src/graphManipulation.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Module for functions that manipulate the graph.\n *\n * @copyright  2022 Paola Maneggia\n * @author     Paola Maneggia <paola.maneggia@gmail.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n * @module     block/availdep\n */\n\n/**\n * Given a list of dependencies, remove the isolated nodes\n * and return the remaining list.\n *\n * @param {{id, name, depend, predecessor}[]} dependencies\n * @returns {{id, name, depend, predecessor}[]}\n */\nexport function removeDisconnectedNodes(dependencies) {\n    let notIsolatedNodes = computeNotIsolatedNodes(dependencies);\n    return dependencies.filter(n => notIsolatedNodes.has(n.id));\n}\n\n/* eslint-disable jsdoc/require-jsdoc */\n/* eslint-disable require-jsdoc */\n\nfunction computeNotIsolatedNodes(dependencies) {\n    let notIsolatedNodes = new Set();\n    dependencies.forEach(node => {\n        if (hasPredecessor(node)) {\n            notIsolatedNodes.add(node.id);\n            addAllPredecessors(node, notIsolatedNodes);\n        }\n    });\n    return notIsolatedNodes;\n}\n\nfunction hasPredecessor(node) {\n    return node.depend && computePredecessors(node).length > 0;\n}\n\nfunction computePredecessors(node) {\n    return node.depend.c.filter(x => x.type === 'completion');\n}\n\nfunction addAllPredecessors(node, notIsolatedNodes) {\n    computePredecessors(node).forEach(x => notIsolatedNodes.add(x.cm === -1 ? x.predecessor : x.cm));\n}\n\n/* eslint-enable jsdoc/require-jsdoc */\n/* eslint-enable require-jsdoc */\n\n/**\n * Fix dangling references to missing course modules.\n *\n * @param {{id, name, depend, predecessor}[]} dependencies is modified by this function:\n * Dangling references are replaced by -2 and if any is found a \"missing\" node with id -2 is added.\n * @param {string} missingString lang string for a missing course module\n */\n export function fixDanglingReferences(dependencies, missingString) {\n    const ids = dependencies.map(x => x.id).concat([-1]);\n    let danglingReferenceFound = false;\n    dependencies.forEach(\n        node => {\n            if (node.depend) {\n                let found = handleDanglingReferencesInNode(node.depend, ids);\n                danglingReferenceFound ||= found;\n            }\n        }\n    );\n    if (danglingReferenceFound) {\n        dependencies.push({id: -2, name: missingString, depend: null, predecessor: null});\n    }\n}\n\n/**\n * Recursively fix dangling references in depend expression.\n * @param {object} depend objects expressing the conditions for the availability of this node, is modified by the function call\n * @param {int[]} ids the list of valid ids\n * @return {boolean} was a dangling reference found and replaced\n */\nfunction handleDanglingReferencesInNode(depend, ids) {\n    if (depend.op) {\n        let danglingReferenceFound = false;\n        depend.c.forEach(\n            d => {\n                let found = handleDanglingReferencesInNode(d, ids);\n                danglingReferenceFound ||= found;\n            }\n        );\n        return danglingReferenceFound;\n    } else {\n        if (depend.type === 'completion' && !ids.includes(depend.cm)) {\n            depend.cm = -2;\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"],"names":["computePredecessors","node","depend","c","filter","x","type","handleDanglingReferencesInNode","ids","op","danglingReferenceFound","forEach","d","found","includes","cm","dependencies","missingString","map","id","concat","push","name","predecessor","notIsolatedNodes","Set","length","hasPredecessor","add","addAllPredecessors","computeNotIsolatedNodes","n","has"],"mappings":"mFAsDSA,oBAAoBC,aAClBA,KAAKC,OAAOC,EAAEC,QAAO,SAAAC,SAAgB,eAAXA,EAAEC,iBAuC9BC,+BAA+BL,OAAQM,QACxCN,OAAOO,GAAI,KACPC,wBAAyB,SAC7BR,OAAOC,EAAEQ,SACL,SAAAC,OACQC,MAAQN,+BAA+BK,EAAGJ,KAC9CE,yBAAAA,uBAA2BG,UAG5BH,6BAEa,eAAhBR,OAAOI,OAA0BE,IAAIM,SAASZ,OAAOa,MACrDb,OAAOa,IAAM,GACN,mGAnCoBC,aAAcC,mBAC3CT,IAAMQ,aAAaE,KAAI,SAAAb,UAAKA,EAAEc,MAAIC,OAAO,EAAE,IAC7CV,wBAAyB,EAC7BM,aAAaL,SACT,SAAAV,SACQA,KAAKC,OAAQ,KACTW,MAAQN,+BAA+BN,KAAKC,OAAQM,KACxDE,yBAAAA,uBAA2BG,WAInCH,wBACAM,aAAaK,KAAK,CAACF,IAAK,EAAGG,KAAML,cAAef,OAAQ,KAAMqB,YAAa;;;;;;;;;SArD3CP,kBAChCQ,0BAOyBR,kBACzBQ,iBAAmB,IAAIC,WAC3BT,aAAaL,SAAQ,SAAAV,gBASDA,aACbA,KAAKC,QAAUF,oBAAoBC,MAAMyB,OAAS,GATjDC,CAAe1B,QACfuB,iBAAiBI,IAAI3B,KAAKkB,aAeVlB,KAAMuB,kBAC9BxB,oBAAoBC,MAAMU,SAAQ,SAAAN,UAAKmB,iBAAiBI,KAAc,IAAVvB,EAAEU,GAAYV,EAAEkB,YAAclB,EAAEU,OAfpFc,CAAmB5B,KAAMuB,sBAG1BA,iBAfgBM,CAAwBd,qBACxCA,aAAaZ,QAAO,SAAA2B,UAAKP,iBAAiBQ,IAAID,EAAEZ"}
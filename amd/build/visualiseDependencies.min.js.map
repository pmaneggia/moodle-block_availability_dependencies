{"version":3,"file":"visualiseDependencies.min.js","sources":["../src/visualiseDependencies.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Visualise dependencies.\n *\n * @copyright  2022 Paola Maneggia, Mathias Kegelmann\n * @author     Paola Maneggia <paola.maneggia@gmail.com>, Mathias Kegelmann <mathias.kegelmann@gmail.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n * @module     block/availdep\n */\n\n/* global d3 */\n/* eslint-disable no-nested-ternary */\n\nimport Ajax from 'core/ajax';\nimport {removeDisconnectedNodes, fixDanglingReferences} from 'block_availdep/graphManipulation';\n\nexport const init = (courseid, fullparam) => {\n    Promise.all(\n        Ajax.call([{\n            methodname: 'core_get_string',\n            args: {stringid: 'missing', component: 'availability_completion'}\n        },\n        {\n            methodname: 'block_availdep_fetch_course_modules_with_names_and_dependencies',\n            args: {courseid: courseid}\n        }])\n    ).then(([missingString, dependencies]) => {\n            let dimensions = determineSvgSize();\n            setupSvg(dimensions);\n            dependencies.forEach(d => {\n                d.depend = JSON.parse(d.depend);\n            });\n            dependencies = removeDisconnectedNodes(dependencies);\n            fixDanglingReferences(dependencies, missingString);\n            let simulation;\n            if (fullparam === 'no') {\n                simulation = generateSimplifiedSimulation(dependencies);\n                displaySimplifiedGraph(simulation);\n            } else {\n                simulation = generateFullSimulation(dependencies);\n                displayFullGraph(simulation);\n            }\n            rememberD3Selections();\n            storeAncestorEdgesAndNodesInAllNodes(edges);\n            simulation.on('tick', tick);\n            makeDraggable(simulation);\n            makeDoubleClickable(simulation);\n            return;\n        }).catch();\n};\n\nlet toggleHighlight = 0;\n\nlet nodeColour = '#AEDAEA';\nlet missingColour = '#FF2020';\nlet textColour = '#364958';\nlet arrowColour = '#516E84';\nlet andColour = '#FFB400';\nlet orColour = '#CEFF1A';\nlet notAndColour = '#F9CFF2';\nlet notOrColour = '#D1FAFF';\nlet otherOperatorColour = '#D1FAFF';\nlet notColour = '#EA7B5D';\n\nlet fullNodeRadius = 50;\nlet operatorRadius = 20;\n\nlet arrowWidth = 2;\n\nlet svgWidth;\n\n/**\n * Set width, height and viewBox of the svg element of class 'availdep'.\n * @param {Object} dimensions\n * @param {number} dimensions.width\n * @param {number} dimensions.height\n */\nfunction setupSvg(dimensions) {\n    d3.select('svg.availdep')\n        .attr('width', dimensions.width)\n        .attr('height', dimensions.height)\n        .attr('viewBox', -dimensions.width / 2 + ' ' + -dimensions.height / 2\n            + ' ' + dimensions.width + ' ' + dimensions.height);\n    addMarker();\n    addFilterDropShadow();\n}\n\n/**\n * Add marker elements to display arrows.\n */\nfunction addMarker() {\n    let dev = d3.select('g.availdep').append('defs');\n    dev.append('marker')\n      .attr('id', 'arrow')\n      .attr('viewBox', \"0 0 10 10\")\n      .attr('refX', 23)\n      .attr('refY', 5)\n      .attr('markerUnits', 'strokeWidth')\n      .attr('markerWidth', 6)\n      .attr('markerHeight', 8)\n      .attr('orient', 'auto')\n    .append('path')\n      .attr('fill', arrowColour)\n      .attr('d', 'M 0 0 L 10 5 L 0 10 z');\n\n    dev.append('marker')\n      .attr('id', 'arrowToActivity')\n      .attr('viewBox', \"0 0 10 10\")\n      .attr('refX', 52)\n      .attr('refY', 5)\n      .attr('markerUnits', 'strokeWidth')\n      .attr('markerWidth', 6)\n      .attr('markerHeight', 8)\n      .attr('orient', 'auto')\n    .append('path')\n      .attr('fill', arrowColour)\n      .attr('d', 'M 0 0 L 10 5 L 0 10 z');\n\n    dev.append('marker')\n      .attr('id', 'arrowToOperator')\n      .attr('viewBox', \"0 0 10 10\")\n      .attr('refX', 27)\n      .attr('refY', 5)\n      .attr('markerUnits', 'strokeWidth')\n      .attr('markerWidth', 6)\n      .attr('markerHeight', 8)\n      .attr('orient', 'auto')\n    .append('path')\n      .attr('fill', arrowColour)\n      .attr('d', 'M 0 0 L 10 5 L 0 10 z');\n}\n\n/**\n * Add feDropShadow to improve contrast.\n */\nfunction addFilterDropShadow() {\n    let dev = d3.select('g.availdep defs');\n    dev.append('filter')\n      .attr('id', 'textShadow')\n    .append('feDropShadow')\n      .attr('dx', 0)\n      .attr('dy', 0)\n      .attr('stdDeviation', 2)\n      .attr('flood-color', 'white')\n      .attr('flood-opacity', 1);\n}\n\n/**\n * Compute the width and height for the svg of class 'availdep'\n * element reading the ones of the parent.\n * @returns {{width: number, height: number}}\n */\nfunction determineSvgSize() {\n    let svg = document.querySelector('svg.availdep');\n    let width = svg.parentNode.clientWidth;\n    let orientation = screen.orientation?.type;\n    let height = orientation === \"portrait-primary\" ? width * 1.3 : width * 0.6;\n    svgWidth = width;\n    return {width, height};\n}\n\n/**\n * Generate a simulation, using the nodes and edges (links)\n * extracted from the dependencies between course modules.\n * The nodes are indexed by the course module id.\n * @param {{id, name, depend, predecessor}[]} dependencies\n * @returns {Object} d3 simulation object\n */\nfunction generateSimplifiedSimulation(dependencies) {\n    return d3.forceSimulation(dependencies)\n        .force('x0', d3.forceX())\n        .force('y0', d3.forceY())\n        .force('collide', d3.forceCollide().radius(20))\n        .force('charge', d3.forceManyBody().strength(-300))\n        .force('link', d3.forceLink(computeEdgesSimplifiedDependencies(dependencies)).distance(200).id(d => d.id));\n}\n\n/**\n * Generate a simulation, using the nodes and edges (links)\n * extracted from the dependencies between course modules.\n * The activity nodes are indexed by the course module id,\n * the operator nodes are indexed by a generated unique id.\n * @param {{id, name, depend, predecessor}[]} dependencies\n * @returns {Object} d3 simulation object\n */\nfunction generateFullSimulation(dependencies) {\n    let {edges, nodes} = computeEdgesAndNodesFullDependencies(dependencies);\n    return d3.forceSimulation(nodes)\n        .force('x0', d3.forceX())\n        .force('y0', d3.forceY())\n        .force('isSource', d3.forceX(-svgWidth / 3).strength(n => n.isSource))\n        .force('isTarget', d3.forceX(svgWidth / 3).strength(n => n.isTarget))\n        .force('collide', d3.forceCollide(100).radius(n => (n.genus === 'activity' ? fullNodeRadius : operatorRadius) + 30))\n        .force('charge', d3.forceManyBody().strength(-300))\n        .force('link', d3.forceLink(edges).distance(50).id(d => d.id));\n}\n\n/**\n * For a simplified representation, flatten any nesting.\n * @param {{id, name, depend, predecessor}[]} dependencies\n * @return {Object[]}\n */\nfunction computeEdgesSimplifiedDependencies(dependencies) {\n    // For an array of nested dependencies\n    // extract all the cm.id of leaves of type 'completion'\n    let leaves = (depend => // TODO fix small bug here d.op && !d.type\n        depend.c.flatMap(d => d.op ? leaves(d) : (d.type === 'completion' ? d.cm : [])));\n    return dependencies\n        .filter(({depend}) => (depend !== null))\n        .map(({id, name, depend, predecessor}) =>\n            leaves(depend).map(cm => {\n                return {\n                    target: id,\n                    source: cm === -1 ? predecessor : cm,\n                    name: name\n                };\n            }))\n        .flat();\n}\n\n/**\n * For a full representation we need nodes for the operators besides the nodes\n * representing the activities. For each node we use fields id, name, genus (activity or operator),\n * isSource and isTarget (the last two are for the layout - sort of extenden fuzzy logic,\n * they are a quantity instead of a boolean).\n * An activity node has as id its course module id and as name its name.\n * An operator node has as id the a uniquely generated id.\n *\n * For each completion of an activity there is a flag 'e' which\n * can have value 0, 1, 2 or 3 (meaning: activity (0) should not be completed; (1) must be completed;\n * (2) must be completed an passed; (3) must be completed and failed).\n * TODO Add a node with that flag between the activity and the previous node.\n * @param {{id, name, depend, predecessor}[]} dependencies\n * @return {{edges: Object[], nodes: Object[]}}\n */\nfunction computeEdgesAndNodesFullDependencies(dependencies) {\n\n    let onlyNonCompletionConditionsIn = function(dependList) {\n        return dependList.filter(c => (c.type && c.type == 'completion' || (!c.type && c.op))).length === 0;\n    };\n\n    let uid = 0;\n\n    let getNextUID = function() {\n        return 'uid_' + uid++;\n    };\n\n    let extractActivityNodes = function(dependencies) {\n        return dependencies.map(d => {\n            return {\n                id: d.id,\n                name: d.name,\n                genus: 'activity',\n                isSource: 0,\n                isTarget: 0,\n            };\n        });\n    };\n\n    let edges = [];\n    let nodes = extractActivityNodes(dependencies);\n\n    // 'id' is the id field of the target node, of genus 'operator' after the first call.\n    // toGenus: genus of the target node ('activity' or 'operator')\n    // dependList the list of dependencies that have the node with id id as target\n    // predecessor is the cmid of the activity node for which we are extracting the information,\n    // to be used if in the nesting of dependencies there will be one with {type: 'completion', cm:-1}\n    // An edge has the same genus as its target.\n    let extractEdgesAndNodes = function(id, toGenus, dependList, predecessor) {\n        dependList.forEach(el => {\n            if (!el.type && el.op && !onlyNonCompletionConditionsIn(el.c)) {\n                // Generate node\n                let newNode = {\n                    id: getNextUID(),\n                    name: el.op,\n                    genus: 'operator',\n                    isTarget: 0.1,\n                    isSource: 0.1\n                };\n                nodes.push(newNode);\n                // Generate edge\n                let newEdge = {\n                    target: id,\n                    source: newNode.id,\n                    toGenus: toGenus\n                };\n                edges.push(newEdge);\n                // Recursive call\n                extractEdgesAndNodes(newNode.id, 'operator', el.c, predecessor);\n            } else if (el.type === 'completion' && el.e > 0) {\n                // Generate edge\n                let newEdge = {\n                    target: id,\n                    source: el.cm === -1 ? predecessor : el.cm,\n                    toGenus: toGenus\n                };\n                // Increase isSource of the source node to a max of 1.5\n                let sn = nodes.find(n => n.id === newEdge.source);\n                sn.isSource = (sn.isSource + 0.6 > 1.5 ? 1.5 : sn.isSource + 0.6);\n                edges.push(newEdge);\n            } else if (el.type === 'completion' && el.e === 0) {\n                // Connect with two edges a 'not' node in between\n                let newNode = {\n                    id: getNextUID(),\n                    name: 'not',\n                    genus: 'operator',\n                    isTarget: 0.1,\n                    isSource: 0.1\n                };\n                let newEdgeFromNot = {\n                    target: id,\n                    source: newNode.id,\n                    toGenus: toGenus\n                };\n                let newEdgeToNot = {\n                    target: newNode.id,\n                    source: el.cm === -1 ? predecessor : el.cm,\n                    toGenus: 'operator'\n                };\n                nodes.push(newNode);\n                edges.push(newEdgeFromNot);\n                edges.push(newEdgeToNot);\n                // Increase isSource of the source node to a max of 1.5\n                let sn = nodes.find(n => n.id === newEdgeToNot.source);\n                sn.isSource = (sn.isSource + 0.6 > 1.5 ? 1.5 : sn.isSource + 0.6);\n            }\n        });\n    };\n\n    dependencies.forEach(a => {\n        if (a.depend !== null) {\n            // If an activity has some availability conditions, set the value for isTarget in its node.\n            // For the moment I am not checking if the conditions are of the wrong type\n            nodes.find(n => n.id === a.id).isTarget = 0.9;\n            extractEdgesAndNodes(a.id, 'activity', [a.depend], a.predecessor);\n        }\n    });\n\n    return {edges, nodes};\n}\n\n/**\n * Use d3 to display nodes and edges (links).\n * @param {Object} simulation - d3 simulation object\n */\nfunction displaySimplifiedGraph(simulation) {\n    displaySimplifiedEdges(simulation.force('link').links());\n    displaySimplifiedNodesAndLabels(simulation.nodes());\n}\n\n/**\n * Add the graphical elements to display the edges.\n * @param {Object[]} sEdges - Edges (links) in the d3 simulation.\n */\n function displaySimplifiedEdges(sEdges) {\n    d3.select('g.availdep').append('g').selectAll('line').data(sEdges)\n        .enter().append('line')\n        .attr('stroke', arrowColour)\n        .attr('stroke-width', arrowWidth + 'px')\n        .attr(\"stroke-linecap\", \"round\")\n        .attr('marker-end', 'url(#arrow)');\n}\n\n/**\n * Use d3 to display nodes and edges (links).\n * @param {Object} simulation - d3 simulation object\n */\n function displayFullGraph(simulation) {\n    displayFullEdges(simulation.force('link').links());\n    displayFullNodesAndLabels(simulation.nodes());\n}\n\n/**\n * Add the graphical elements to display the edges.\n * @param {Object[]} sEdges - Edges (links) in the d3 simulation.\n */\nfunction displayFullEdges(sEdges) {\n    d3.select('g.availdep').append('g').selectAll('line').data(sEdges)\n        .enter().append('line')\n        .attr('stroke', textColour)\n        .attr('stroke-opacity', 0.7)\n        .attr('stroke-width', arrowWidth + 'px')\n        .attr(\"stroke-linecap\", \"round\")\n        .attr('marker-end', e => e.toGenus === 'activity' ?\n            'url(#arrowToActivity' :\n            'url(#arrowToOperator');\n}\n\n/**\n * Add the graphical elements to display the nodes and labels.\n * @param {Object[]} sNodes - Nodes in the d3 simulation.\n */\n function displaySimplifiedNodesAndLabels(sNodes) {\n    d3.select('g.availdep').append('g').selectAll('circle').data(sNodes)\n        .join('circle')\n        .attr('fill', n => n.id === -2 ? missingColour : nodeColour)\n        .attr('stroke', 'white')\n        .attr('r', 16);\n    d3.select('g.availdep').append('g').selectAll('text').data(sNodes)\n        .join('text')\n        .attr('fill', textColour)\n        .attr('font-family', 'sans-serif')\n        .attr('font-weight', 'bold')\n      .clone().lower()\n        .attr('stroke', 'white')\n        .attr('stroke-width', 4)\n        .attr('stroke-opacity', 0.5);\n}\n\n/**\n * Add the graphical elements to display the nodes and labels.\n * @param {Object[]} sNodes - Nodes in the d3 simulation.\n */\n function displayFullNodesAndLabels(sNodes) {\n    d3.select('g.availdep').append('g').selectAll('circle').data(sNodes)\n        .join('circle')\n        .attr('fill', n => n.genus === 'activity' ? (n.id === -2 ? missingColour : nodeColour)\n            : n.name === '&' ? andColour\n            : n.name === '|' ? orColour\n            : n.name === '!&' ? notAndColour\n            : n.name === '!|' ? notOrColour\n            : n.name === 'not' ? notColour\n            : otherOperatorColour)\n        .attr('stroke', 'white')\n        .attr('stroke-width', 3)\n        .attr('r', n => n.genus === 'activity' ? fullNodeRadius : operatorRadius);\n    d3.select('g.availdep').append('g').selectAll('text').data(sNodes)\n        .join('text')\n        .attr('fill', textColour)\n        .attr('font-family', 'sans-serif')\n        .attr('font-weight', 'bold')\n        .attr('text-anchor', 'middle')\n        .attr('dx', -5)\n        .attr('dominant-baseline', 'middle')\n        .attr('dy', 5)\n        .attr('filter', 'url(#textShadow)');\n}\n\nlet edges, nodes, labels;\n\n/**\n * Save the graphical representation of edges, nodes and labals.\n */\nfunction rememberD3Selections() {\n    edges = d3.select('g.availdep').selectAll('line');\n    nodes = d3.select('g.availdep').selectAll('circle');\n    labels = d3.select('g.availdep').selectAll('text');\n}\n\n/**\n * Update the simulation.\n */\nfunction tick() {\n    nodes\n        .attr('cx', n => n.x)\n        .attr('cy', n => n.y);\n    edges\n        .attr('x1', e => e.source.x)\n        .attr('y1', e => e.source.y)\n        .attr('x2', e => e.target.x)\n        .attr('y2', e => e.target.y);\n    labels\n        .attr('x', n => n.x + 5)\n        .attr('y', n => n.y - 5)\n        .text(n => n.name);\n\n}\n\n/**\n * Make nodes draggable.\n * Once dragged a node is fixed to its assigned position in the simulation.\n * @param {Object} simulation - d3 simulation object\n */\nfunction makeDraggable(simulation) {\n    nodes\n        .call(d3.drag()\n        .on('start', (event, n) => {\n            if (!event.active) {\n                simulation.alphaTarget(0.3).restart();\n            }\n            n.fx = event.x;\n            n.fy = event.y;\n        })\n        .on('drag',\n            (event, n) => {\n                n.fx = event.x;\n                n.fy = event.y;\n            })\n        .on('end', (event) => {\n            if (!event.active) {\n                simulation.alphaTarget(0);\n            }\n        })\n        );\n}\n\n/**\n * Add callback for click event to each node.\n */\nfunction makeDoubleClickable() {\n    nodes.on('click', highlightDependencies);\n}\n\n/**\n * Stores ancestors of each node as an additional property.\n * We need this for the highlight function.\n * @param {Object[]} allEdges\n * @returns {Object[]}\n */\nfunction storeAncestorEdgesAndNodesInAllNodes(allEdges) {\n    return nodes.data().forEach(n => computeAndStoreAncestorEdgesAndNodes(n, allEdges));\n}\n\n/**\n * Compute the ancestor edges and nodes for a given node and stores then in an\n * additional property 'ancestors' of the node.\n * Even if it would be logically absurd to build a cycle in the directed graph of dependencies,\n * there is no guarantee that this does not happen. Moreover a cycle per se does not mean that\n * some activites are unreachable, since they can be negated.\n * @param {Object} node a d3 (circle) node from a simulation\n * @param {Object[]} allEdges\n */\nfunction computeAndStoreAncestorEdgesAndNodes(node, allEdges) {\n    let aNodes = new Set();\n    let aEdges = new Set();\n    let toBeExaminedNodes = [node];\n    while (toBeExaminedNodes.length) {\n        // Each time one element of the queue of nodes to be examined is moved to the set aNodes\n        let currentNode = toBeExaminedNodes.shift();\n        aNodes.add(currentNode);\n        // Iterate over the edges and look for the ones that have the current node as target\n        allEdges.data().forEach(ed => {\n            if (ed.target.id === currentNode.id) {\n                aEdges.add(ed);\n                if (!aNodes.has(ed.source)) {\n                    toBeExaminedNodes.push(ed.source);\n                }\n            }\n        });\n    }\n    node.ancestors = [...aNodes].concat([...aEdges]);\n}\n\n/**\n * Check if an edge is ancestor of node\n * @param {*} edgeOrNode the edge or node to check\n * @param {*} node\n * @return {Object[]} the list of ancestor nodes\n */\nfunction isAncestor(edgeOrNode, node) {\n    return node.ancestors.includes(edgeOrNode);\n}\n\n/**\n * Toggle highlight function. The opacity of all nodes that are not\n * ancestory of a given node is reduced or set back to normal.\n */\nfunction highlightDependencies() {\n    if (toggleHighlight === 0) {\n        // Reduce the opacity of all but the ancestor nodes\n        let d = d3.select(this).data()[0];\n        nodes.style(\"opacity\", function(o) {\n            return isAncestor(o, d) ? 1 : 0.1;\n        });\n        edges.style(\"opacity\", function(o) {\n            return isAncestor(o, d) ? 1 : 0.1;\n        });\n        // Mark hightlighting as on\n        toggleHighlight = 1;\n    } else {\n        // Put opacity back to 1 for all nodes and links\n        nodes.style(\"opacity\", 1);\n        edges.style(\"opacity\", 1);\n        // Mark highlighting as off\n        toggleHighlight = 0;\n    }\n}\n\n/* eslint-enable no-nested-ternary */\n"],"names":["courseid","fullparam","Promise","all","Ajax","call","methodname","args","stringid","component","then","width","orientation","simulation","allEdges","missingString","dependencies","dimensions","d3","select","attr","height","dev","append","setupSvg","document","querySelector","parentNode","clientWidth","screen","_screen$orientation","type","svgWidth","forEach","d","depend","JSON","parse","forceSimulation","force","forceX","forceY","forceCollide","radius","forceManyBody","strength","forceLink","leaves","c","flatMap","op","cm","filter","map","id","name","predecessor","target","source","flat","computeEdgesSimplifiedDependencies","distance","generateSimplifiedSimulation","sEdges","links","selectAll","data","enter","arrowWidth","sNodes","nodes","join","n","clone","lower","displaySimplifiedGraph","onlyNonCompletionConditionsIn","dependList","length","uid","getNextUID","extractActivityNodes","genus","isSource","isTarget","edges","extractEdgesAndNodes","toGenus","el","e","newEdge","sn","find","push","newNode","newEdgeFromNot","newEdgeToNot","a","computeEdgesAndNodesFullDependencies","generateFullSimulation","displayFullGraph","labels","node","aNodes","Set","aEdges","toBeExaminedNodes","currentNode","shift","add","ed","has","ancestors","_toConsumableArray","concat","computeAndStoreAncestorEdgesAndNodes","on","tick","drag","event","active","alphaTarget","restart","fx","x","fy","y","makeDraggable","highlightDependencies","catch","toggleHighlight","text","isAncestor","edgeOrNode","includes","this","style","o"],"mappings":"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"}
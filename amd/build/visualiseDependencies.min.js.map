{"version":3,"file":"visualiseDependencies.min.js","sources":["../src/visualiseDependencies.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Visualise dependencies.\n *\n * @copyright  2022 Paola Maneggia, Mathias Kegelmann\n * @author     Paola Maneggia <paola.maneggia@gmail.com>, Mathias Kegelmann <mathias.kegelmann@gmail.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n * @module     block/availdep\n */\n\n/* global d3 */\n/* eslint-disable no-nested-ternary */\n\nimport Ajax from 'core/ajax';\nimport {removeDisconnectedNodes, fixDanglingReferences} from 'block_availdep/graphManipulation';\n\nexport const init = (courseid, fullparam) => {\n    Promise.all(\n        Ajax.call([{\n            methodname: 'core_get_string',\n            args: {stringid: 'missing', component: 'availability_completion'}\n        },\n        {\n            methodname: 'block_availdep_fetch_course_modules_with_names_and_dependencies',\n            args: {courseid: courseid}\n        }])\n    ).then(([missingString, dependencies]) => {\n            let dimensions = determineSvgSize();\n            setupSvg(dimensions);\n            dependencies.forEach(d => {\n                d.depend = JSON.parse(d.depend);\n            });\n            dependencies = removeDisconnectedNodes(dependencies);\n            fixDanglingReferences(dependencies, missingString);\n            let simulation;\n            if (fullparam === 'no') {\n                simulation = generateSimplifiedSimulation(dependencies);\n                displaySimplifiedGraph(simulation);\n            } else {\n                simulation = generateFullSimulation(dependencies);\n                displayFullGraph(simulation);\n            }\n            rememberD3Selections();\n            storeAncestorEdgesAndNodesInAllNodes(edges);\n            simulation.on('tick', tick);\n            makeDraggable(simulation);\n            makeDoubleClickable(simulation);\n            return;\n        }).catch();\n};\n\nlet toggleHighlight = 0;\n\nlet nodeColour = '#AEDAEA';\nlet missingColour = '#FF2020';\nlet textColour = '#364958';\nlet arrowColour = '#516E84';\nlet andColour = '#FFB400';\nlet orColour = '#CEFF1A';\nlet notAndColour = '#F9CFF2';\nlet notOrColour = '#D1FAFF';\nlet otherOperatorColour = '#D1FAFF';\nlet notColour = '#EA7B5D';\n\nlet fullNodeRadius = 50;\nlet operatorRadius = 20;\n\nlet arrowWidth = 2;\n\nlet svgWidth;\n\n/**\n * Set width, height and viewBox of the svg element of class 'availdep'.\n * @param {Object} dimensions\n * @param {number} dimensions.width\n * @param {number} dimensions.height\n */\nfunction setupSvg(dimensions) {\n    d3.select('svg.availdep')\n        .attr('width', dimensions.width)\n        .attr('height', dimensions.height)\n        .attr('viewBox', -dimensions.width / 2 + ' ' + -dimensions.height / 2\n            + ' ' + dimensions.width + ' ' + dimensions.height);\n    addMarker();\n    addFilterDropShadow();\n}\n\n/**\n * Add marker elements to display arrows.\n */\nfunction addMarker() {\n    let dev = d3.select('g.availdep').append('defs');\n    dev.append('marker')\n      .attr('id', 'arrow')\n      .attr('viewBox', \"0 0 10 10\")\n      .attr('refX', 23)\n      .attr('refY', 5)\n      .attr('markerUnits', 'strokeWidth')\n      .attr('markerWidth', 6)\n      .attr('markerHeight', 8)\n      .attr('orient', 'auto')\n    .append('path')\n      .attr('fill', arrowColour)\n      .attr('d', 'M 0 0 L 10 5 L 0 10 z');\n\n    dev.append('marker')\n      .attr('id', 'arrowToActivity')\n      .attr('viewBox', \"0 0 10 10\")\n      .attr('refX', 52)\n      .attr('refY', 5)\n      .attr('markerUnits', 'strokeWidth')\n      .attr('markerWidth', 6)\n      .attr('markerHeight', 8)\n      .attr('orient', 'auto')\n    .append('path')\n      .attr('fill', arrowColour)\n      .attr('d', 'M 0 0 L 10 5 L 0 10 z');\n\n    dev.append('marker')\n      .attr('id', 'arrowToOperator')\n      .attr('viewBox', \"0 0 10 10\")\n      .attr('refX', 27)\n      .attr('refY', 5)\n      .attr('markerUnits', 'strokeWidth')\n      .attr('markerWidth', 6)\n      .attr('markerHeight', 8)\n      .attr('orient', 'auto')\n    .append('path')\n      .attr('fill', arrowColour)\n      .attr('d', 'M 0 0 L 10 5 L 0 10 z');\n}\n\n/**\n * Add feDropShadow to improve contrast.\n */\nfunction addFilterDropShadow() {\n    let dev = d3.select('g.availdep defs');\n    dev.append('filter')\n      .attr('id', 'textShadow')\n    .append('feDropShadow')\n      .attr('dx', 0)\n      .attr('dy', 0)\n      .attr('stdDeviation', 2)\n      .attr('flood-color', 'white')\n      .attr('flood-opacity', 1);\n}\n\n/**\n * Compute the width and height for the svg of class 'availdep'\n * element reading the ones of the parent.\n * @returns {{width: number, height: number}}\n */\nfunction determineSvgSize() {\n    let svg = document.querySelector('svg.availdep');\n    console.log('Paola element ' + document.querySelector('div.drawercontent').clientWidth);\n    //let width = svg.parentNode.parentNode.clientWidth;\n    let width = document.querySelector('div.drawercontent').clientWidth;\n    let orientation = screen.orientation?.type;\n    let height = orientation === \"landscape-primary\" ? width * 1.3 : width * 0.6;\n    return {width, height};\n}\n\n/**\n * Generate a simulation, using the nodes and edges (links)\n * extracted from the dependencies between course modules.\n * The nodes are indexed by the course module id.\n * @param {{id, name, depend, predecessor}[]} dependencies\n * @returns {Object} d3 simulation object\n */\nfunction generateSimplifiedSimulation(dependencies) {\n    return d3.forceSimulation(dependencies)\n        .force('x0', d3.forceX())\n        .force('y0', d3.forceY())\n        .force('collide', d3.forceCollide().radius(20))\n        .force('charge', d3.forceManyBody().strength(-300))\n        .force('link', d3.forceLink(computeEdgesSimplifiedDependencies(dependencies)).distance(200).id(d => d.id));\n}\n\n/**\n * Generate a simulation, using the nodes and edges (links)\n * extracted from the dependencies between course modules.\n * The activity nodes are indexed by the course module id,\n * the operator nodes are indexed by a generated unique id.\n * @param {{id, name, depend, predecessor}[]} dependencies\n * @returns {Object} d3 simulation object\n */\nfunction generateFullSimulation(dependencies) {\n    let {edges, nodes} = computeEdgesAndNodesFullDependencies(dependencies);\n    return d3.forceSimulation(nodes)\n        .force('x0', d3.forceX())\n        .force('y0', d3.forceY())\n        .force('isSource', d3.forceX(-svgWidth / 3).strength(n => n.isSource))\n        .force('isTarget', d3.forceX(svgWidth / 3).strength(n => n.isTarget))\n        .force('collide', d3.forceCollide(100).radius(n => (n.genus === 'activity' ? fullNodeRadius : operatorRadius) + 30))\n        .force('charge', d3.forceManyBody().strength(-300))\n        .force('link', d3.forceLink(edges).distance(50).id(d => d.id));\n}\n\n/**\n * For a simplified representation, flatten any nesting.\n * @param {{id, name, depend, predecessor}[]} dependencies\n * @return {Object[]}\n */\nfunction computeEdgesSimplifiedDependencies(dependencies) {\n    // For an array of nested dependencies\n    // extract all the cm.id of leaves of type 'completion'\n    let leaves = (depend => // TODO fix small bug here d.op && !d.type\n        depend.c.flatMap(d => d.op ? leaves(d) : (d.type === 'completion' ? d.cm : [])));\n    return dependencies\n        .filter(({depend}) => (depend !== null))\n        .map(({id, name, depend, predecessor}) =>\n            leaves(depend).map(cm => {\n                return {\n                    target: id,\n                    source: cm === -1 ? predecessor : cm,\n                    name: name\n                };\n            }))\n        .flat();\n}\n\n/**\n * For a full representation we need nodes for the operators besides the nodes\n * representing the activities. For each node we use fields id, name, genus (activity or operator),\n * isSource and isTarget (the last two are for the layout - sort of extenden fuzzy logic,\n * they are a quantity instead of a boolean).\n * An activity node has as id its course module id and as name its name.\n * An operator node has as id the a uniquely generated id.\n *\n * For each completion of an activity there is a flag 'e' which\n * can have value 0, 1, 2 or 3 (meaning: activity (0) should not be completed; (1) must be completed;\n * (2) must be completed an passed; (3) must be completed and failed).\n * TODO Add a node with that flag between the activity and the previous node.\n * @param {{id, name, depend, predecessor}[]} dependencies\n * @return {{edges: Object[], nodes: Object[]}}\n */\nfunction computeEdgesAndNodesFullDependencies(dependencies) {\n\n    let onlyNonCompletionConditionsIn = function(dependList) {\n        return dependList.filter(c => (c.type && c.type == 'completion' || (!c.type && c.op))).length === 0;\n    };\n\n    let uid = 0;\n\n    let getNextUID = function() {\n        return 'uid_' + uid++;\n    };\n\n    let extractActivityNodes = function(dependencies) {\n        return dependencies.map(d => {\n            return {\n                id: d.id,\n                name: d.name,\n                genus: 'activity',\n                isSource: 0,\n                isTarget: 0,\n            };\n        });\n    };\n\n    let edges = [];\n    let nodes = extractActivityNodes(dependencies);\n\n    // 'id' is the id field of the target node, of genus 'operator' after the first call.\n    // toGenus: genus of the target node ('activity' or 'operator')\n    // dependList the list of dependencies that have the node with id id as target\n    // predecessor is the cmid of the activity node for which we are extracting the information,\n    // to be used if in the nesting of dependencies there will be one with {type: 'completion', cm:-1}\n    // An edge has the same genus as its target.\n    let extractEdgesAndNodes = function(id, toGenus, dependList, predecessor) {\n        dependList.forEach(el => {\n            if (!el.type && el.op && !onlyNonCompletionConditionsIn(el.c)) {\n                // Generate node\n                let newNode = {\n                    id: getNextUID(),\n                    name: el.op,\n                    genus: 'operator',\n                    isTarget: 0.1,\n                    isSource: 0.1\n                };\n                nodes.push(newNode);\n                // Generate edge\n                let newEdge = {\n                    target: id,\n                    source: newNode.id,\n                    toGenus: toGenus\n                };\n                edges.push(newEdge);\n                // Recursive call\n                extractEdgesAndNodes(newNode.id, 'operator', el.c, predecessor);\n            } else if (el.type === 'completion' && el.e > 0) {\n                // Generate edge\n                let newEdge = {\n                    target: id,\n                    source: el.cm === -1 ? predecessor : el.cm,\n                    toGenus: toGenus\n                };\n                // Increase isSource of the source node to a max of 1.5\n                let sn = nodes.find(n => n.id === newEdge.source);\n                sn.isSource = (sn.isSource + 0.6 > 1.5 ? 1.5 : sn.isSource + 0.6);\n                edges.push(newEdge);\n            } else if (el.type === 'completion' && el.e === 0) {\n                // Connect with two edges a 'not' node in between\n                let newNode = {\n                    id: getNextUID(),\n                    name: 'not',\n                    genus: 'operator',\n                    isTarget: 0.1,\n                    isSource: 0.1\n                };\n                let newEdgeFromNot = {\n                    target: id,\n                    source: newNode.id,\n                    toGenus: toGenus\n                };\n                let newEdgeToNot = {\n                    target: newNode.id,\n                    source: el.cm === -1 ? predecessor : el.cm,\n                    toGenus: 'operator'\n                };\n                nodes.push(newNode);\n                edges.push(newEdgeFromNot);\n                edges.push(newEdgeToNot);\n                // Increase isSource of the source node to a max of 1.5\n                let sn = nodes.find(n => n.id === newEdgeToNot.source);\n                sn.isSource = (sn.isSource + 0.6 > 1.5 ? 1.5 : sn.isSource + 0.6);\n            }\n        });\n    };\n\n    dependencies.forEach(a => {\n        if (a.depend !== null) {\n            // If an activity has some availability conditions, set the value for isTarget in its node.\n            // For the moment I am not checking if the conditions are of the wrong type\n            nodes.find(n => n.id === a.id).isTarget = 0.9;\n            extractEdgesAndNodes(a.id, 'activity', [a.depend], a.predecessor);\n        }\n    });\n\n    return {edges, nodes};\n}\n\n/**\n * Use d3 to display nodes and edges (links).\n * @param {Object} simulation - d3 simulation object\n */\nfunction displaySimplifiedGraph(simulation) {\n    displaySimplifiedEdges(simulation.force('link').links());\n    displaySimplifiedNodesAndLabels(simulation.nodes());\n}\n\n/**\n * Add the graphical elements to display the edges.\n * @param {Object[]} sEdges - Edges (links) in the d3 simulation.\n */\n function displaySimplifiedEdges(sEdges) {\n    d3.select('g.availdep').append('g').selectAll('line').data(sEdges)\n        .enter().append('line')\n        .attr('stroke', arrowColour)\n        .attr('stroke-width', arrowWidth + 'px')\n        .attr(\"stroke-linecap\", \"round\")\n        .attr('marker-end', 'url(#arrow)');\n}\n\n/**\n * Use d3 to display nodes and edges (links).\n * @param {Object} simulation - d3 simulation object\n */\n function displayFullGraph(simulation) {\n    displayFullEdges(simulation.force('link').links());\n    displayFullNodesAndLabels(simulation.nodes());\n}\n\n/**\n * Add the graphical elements to display the edges.\n * @param {Object[]} sEdges - Edges (links) in the d3 simulation.\n */\nfunction displayFullEdges(sEdges) {\n    d3.select('g.availdep').append('g').selectAll('line').data(sEdges)\n        .enter().append('line')\n        .attr('stroke', textColour)\n        .attr('stroke-opacity', 0.7)\n        .attr('stroke-width', arrowWidth + 'px')\n        .attr(\"stroke-linecap\", \"round\")\n        .attr('marker-end', e => e.toGenus === 'activity' ?\n            'url(#arrowToActivity' :\n            'url(#arrowToOperator');\n}\n\n/**\n * Add the graphical elements to display the nodes and labels.\n * @param {Object[]} sNodes - Nodes in the d3 simulation.\n */\n function displaySimplifiedNodesAndLabels(sNodes) {\n    d3.select('g.availdep').append('g').selectAll('circle').data(sNodes)\n        .join('circle')\n        .attr('fill', n => n.id === -2 ? missingColour : nodeColour)\n        .attr('stroke', 'white')\n        .attr('r', 16);\n    d3.select('g.availdep').append('g').selectAll('text').data(sNodes)\n        .join('text')\n        .attr('fill', textColour)\n        .attr('font-family', 'sans-serif')\n        .attr('font-weight', 'bold')\n      .clone().lower()\n        .attr('stroke', 'white')\n        .attr('stroke-width', 4)\n        .attr('stroke-opacity', 0.5);\n}\n\n/**\n * Add the graphical elements to display the nodes and labels.\n * @param {Object[]} sNodes - Nodes in the d3 simulation.\n */\n function displayFullNodesAndLabels(sNodes) {\n    d3.select('g.availdep').append('g').selectAll('circle').data(sNodes)\n        .join('circle')\n        .attr('fill', n => n.genus === 'activity' ? (n.id === -2 ? missingColour : nodeColour)\n            : n.name === '&' ? andColour\n            : n.name === '|' ? orColour\n            : n.name === '!&' ? notAndColour\n            : n.name === '!|' ? notOrColour\n            : n.name === 'not' ? notColour\n            : otherOperatorColour)\n        .attr('stroke', 'white')\n        .attr('stroke-width', 3)\n        .attr('r', n => n.genus === 'activity' ? fullNodeRadius : operatorRadius);\n    d3.select('g.availdep').append('g').selectAll('text').data(sNodes)\n        .join('text')\n        .attr('fill', textColour)\n        .attr('font-family', 'sans-serif')\n        .attr('font-weight', 'bold')\n        .attr('text-anchor', 'middle')\n        .attr('dx', -5)\n        .attr('dominant-baseline', 'middle')\n        .attr('dy', 5)\n        .attr('filter', 'url(#textShadow)');\n}\n\nlet edges, nodes, labels;\n\n/**\n * Save the graphical representation of edges, nodes and labals.\n */\nfunction rememberD3Selections() {\n    edges = d3.select('g.availdep').selectAll('line');\n    nodes = d3.select('g.availdep').selectAll('circle');\n    labels = d3.select('g.availdep').selectAll('text');\n}\n\n/**\n * Update the simulation.\n */\nfunction tick() {\n    nodes\n        .attr('cx', n => n.x)\n        .attr('cy', n => n.y);\n    edges\n        .attr('x1', e => e.source.x)\n        .attr('y1', e => e.source.y)\n        .attr('x2', e => e.target.x)\n        .attr('y2', e => e.target.y);\n    labels\n        .attr('x', n => n.x + 5)\n        .attr('y', n => n.y - 5)\n        .text(n => n.name);\n\n}\n\n/**\n * Make nodes draggable.\n * Once dragged a node is fixed to its assigned position in the simulation.\n * @param {Object} simulation - d3 simulation object\n */\nfunction makeDraggable(simulation) {\n    nodes\n        .call(d3.drag()\n        .on('start', (event, n) => {\n            if (!event.active) {\n                simulation.alphaTarget(0.3).restart();\n            }\n            n.fx = event.x;\n            n.fy = event.y;\n        })\n        .on('drag',\n            (event, n) => {\n                n.fx = event.x;\n                n.fy = event.y;\n            })\n        .on('end', (event) => {\n            if (!event.active) {\n                simulation.alphaTarget(0);\n            }\n        })\n        );\n}\n\n/**\n * Add callback for click event to each node.\n */\nfunction makeDoubleClickable() {\n    nodes.on('click', highlightDependencies);\n}\n\n/**\n * Stores ancestors of each node as an additional property.\n * We need this for the highlight function.\n * @param {Object[]} allEdges\n * @returns {Object[]}\n */\nfunction storeAncestorEdgesAndNodesInAllNodes(allEdges) {\n    return nodes.data().forEach(n => computeAndStoreAncestorEdgesAndNodes(n, allEdges));\n}\n\n/**\n * Compute the ancestor edges and nodes for a given node and stores then in an\n * additional property 'ancestors' of the node.\n * Even if it would be logically absurd to build a cycle in the directed graph of dependencies,\n * there is no guarantee that this does not happen. Moreover a cycle per se does not mean that\n * some activites are unreachable, since they can be negated.\n * @param {Object} node a d3 (circle) node from a simulation\n * @param {Object[]} allEdges\n */\nfunction computeAndStoreAncestorEdgesAndNodes(node, allEdges) {\n    let aNodes = new Set();\n    let aEdges = new Set();\n    let toBeExaminedNodes = [node];\n    while (toBeExaminedNodes.length) {\n        // Each time one element of the queue of nodes to be examined is moved to the set aNodes\n        let currentNode = toBeExaminedNodes.shift();\n        aNodes.add(currentNode);\n        // Iterate over the edges and look for the ones that have the current node as target\n        allEdges.data().forEach(ed => {\n            if (ed.target.id === currentNode.id) {\n                aEdges.add(ed);\n                if (!aNodes.has(ed.source)) {\n                    toBeExaminedNodes.push(ed.source);\n                }\n            }\n        });\n    }\n    node.ancestors = [...aNodes].concat([...aEdges]);\n}\n\n/**\n * Check if an edge is ancestor of node\n * @param {*} edgeOrNode the edge or node to check\n * @param {*} node\n * @return {Object[]} the list of ancestor nodes\n */\nfunction isAncestor(edgeOrNode, node) {\n    return node.ancestors.includes(edgeOrNode);\n}\n\n/**\n * Toggle highlight function. The opacity of all nodes that are not\n * ancestory of a given node is reduced or set back to normal.\n */\nfunction highlightDependencies() {\n    if (toggleHighlight === 0) {\n        // Reduce the opacity of all but the ancestor nodes\n        let d = d3.select(this).data()[0];\n        nodes.style(\"opacity\", function(o) {\n            return isAncestor(o, d) ? 1 : 0.1;\n        });\n        edges.style(\"opacity\", function(o) {\n            return isAncestor(o, d) ? 1 : 0.1;\n        });\n        // Mark hightlighting as on\n        toggleHighlight = 1;\n    } else {\n        // Put opacity back to 1 for all nodes and links\n        nodes.style(\"opacity\", 1);\n        edges.style(\"opacity\", 1);\n        // Mark highlighting as off\n        toggleHighlight = 0;\n    }\n}\n\n/* eslint-enable no-nested-ternary */\n"],"names":["courseid","fullparam","Promise","all","Ajax","call","methodname","args","stringid","component","then","_ref","simulation","missingString","dependencies","allEdges","dimensions","d3","select","attr","width","height","dev","append","addMarker","setupSvg","document","querySelector","console","log","clientWidth","orientation","screen","_screen$orientation","type","determineSvgSize","forEach","d","depend","JSON","parse","forceSimulation","force","forceX","forceY","forceCollide","radius","forceManyBody","strength","forceLink","leaves","c","flatMap","op","cm","filter","_ref2","map","_ref3","id","name","predecessor","target","source","flat","computeEdgesSimplifiedDependencies","distance","generateSimplifiedSimulation","sEdges","links","selectAll","data","enter","arrowWidth","sNodes","nodes","join","n","clone","lower","displaySimplifiedGraph","edges","onlyNonCompletionConditionsIn","dependList","length","uid","getNextUID","extractActivityNodes","genus","isSource","isTarget","extractEdgesAndNodes","toGenus","el","e","newEdge","sn","find","push","newNode","newEdgeFromNot","newEdgeToNot","a","computeEdgesAndNodesFullDependencies","svgWidth","generateFullSimulation","displayFullGraph","labels","node","aNodes","Set","aEdges","toBeExaminedNodes","currentNode","shift","add","ed","has","ancestors","concat","computeAndStoreAncestorEdgesAndNodes","on","tick","drag","event","active","alphaTarget","restart","fx","x","fy","y","makeDraggable","highlightDependencies","catch","toggleHighlight","text","isAncestor","edgeOrNode","includes","this","style","o"],"mappings":"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"}
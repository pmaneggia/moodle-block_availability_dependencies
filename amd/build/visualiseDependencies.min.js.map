{"version":3,"file":"visualiseDependencies.min.js","sources":["../src/visualiseDependencies.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Visualise dependencies.\n *\n * @copyright  2022 Paola Maneggia, Mathias Kegelmann\n * @author     Paola Maneggia <paola.maneggia@gmail.com>, Mathias Kegelmann <mathias.kegelmann@gmail.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n * @module     block/availdep\n */\n\n/* global d3 */\n/* eslint-disable no-nested-ternary */\n\nimport Ajax from 'core/ajax';\n\nlet full = 'no';\n\nexport const init = (courseid, fullparam) => {\n    full = fullparam;\n    var promises = Ajax.call([{\n        methodname: 'block_availdep_fetch_course_modules_with_names_and_dependencies',\n        args: {courseid: courseid}\n    }\n]);\n\n/* eslint-disable promise/always-return */\npromises[0]\n    .then(dependencies => {\n        let dimensions = determineSvgSize();\n        setupSvg(dimensions);\n        dependencies.forEach(d => {\n            d.depend = JSON.parse(d.depend);\n        });\n        let simulation;\n        if (full === 'no') {\n            simulation = generateSimplifiedSimulation(dependencies);\n            displaySimplifiedGraph(simulation);\n        } else {\n            simulation = generateFullSimulation(dependencies);\n            displayFullGraph(simulation);\n        }\n        rememberD3Selections();\n        storeAncestorEdgesAndNodesInAllNodes(edges);\n        simulation.on('tick', tick);\n        makeDraggable(simulation);\n        makeDoubleClickable(simulation);\n    }).catch();\n};\n/* eslint-enable promise/always-return */\n\nlet toggleHighlight = 0;\n\nlet nodeColour = '#AEDAEA';\nlet textColour = '#364958';\nlet arrowColour = '#516E84';\nlet andColour = '#FFB400';\nlet orColour = '#CEFF1A';\nlet notAndColour = '#F9CFF2';\nlet notOrColour = '#D1FAFF';\nlet otherOperatorColour = '#D1FAFF';\nlet notColour = '#EA7B5D';\n\nlet fullNodeRadius = 50;\nlet operatorRadius = 20;\n\nlet arrowWidth = 2;\n\nlet svgWidth;\n\n/**\n * Set width, height and viewBox of the svg element of class 'availdep'.\n * @param {Object} dimensions\n * @param {number} dimensions.width\n * @param {number} dimensions.height\n */\nfunction setupSvg(dimensions) {\n    d3.select('svg.availdep')\n        .attr('width', dimensions.width)\n        .attr('height', dimensions.height)\n        .attr('viewBox', -dimensions.width / 2 + ' ' + -dimensions.height / 2\n            + ' ' + dimensions.width + ' ' + dimensions.height);\n    addMarker();\n    addFilterDropShadow();\n}\n\n/**\n * Add marker elements to display arrows.\n */\nfunction addMarker() {\n    let dev = d3.select('g.availdep').append('defs');\n    dev.append('marker')\n      .attr('id', 'arrow')\n      .attr('viewBox', \"0 0 10 10\")\n      .attr('refX', 23)\n      .attr('refY', 5)\n      .attr('markerUnits', 'strokeWidth')\n      .attr('markerWidth', 6)\n      .attr('markerHeight', 8)\n      .attr('orient', 'auto')\n    .append('path')\n      .attr('fill', arrowColour)\n      .attr('d', 'M 0 0 L 10 5 L 0 10 z');\n\n    dev.append('marker')\n      .attr('id', 'arrowToActivity')\n      .attr('viewBox', \"0 0 10 10\")\n      .attr('refX', 52)\n      .attr('refY', 5)\n      .attr('markerUnits', 'strokeWidth')\n      .attr('markerWidth', 6)\n      .attr('markerHeight', 8)\n      .attr('orient', 'auto')\n    .append('path')\n      .attr('fill', arrowColour)\n      .attr('d', 'M 0 0 L 10 5 L 0 10 z');\n\n    dev.append('marker')\n      .attr('id', 'arrowToOperator')\n      .attr('viewBox', \"0 0 10 10\")\n      .attr('refX', 27)\n      .attr('refY', 5)\n      .attr('markerUnits', 'strokeWidth')\n      .attr('markerWidth', 6)\n      .attr('markerHeight', 8)\n      .attr('orient', 'auto')\n    .append('path')\n      .attr('fill', arrowColour)\n      .attr('d', 'M 0 0 L 10 5 L 0 10 z');\n}\n\n/**\n * Add feDropShadow to improve contrast.\n */\nfunction addFilterDropShadow() {\n    let dev = d3.select('g.availdep defs');\n    dev.append('filter')\n      .attr('id', 'textShadow')\n    .append('feDropShadow')\n      .attr('dx', 0)\n      .attr('dy', 0)\n      .attr('stdDeviation', 2)\n      .attr('flood-color', 'white')\n      .attr('flood-opacity', 1);\n}\n\n/**\n * Compute the width and height for the svg of class 'availdep'\n * element reading the ones of the parent.\n * @returns {{width: number, height: number}}\n */\nfunction determineSvgSize() {\n    let svg = document.querySelector('svg.availdep');\n    let width = svg.parentNode.clientWidth;\n    let orientation = screen.orientation?.type;\n    let height = orientation === \"portrait-primary\" ? width * 1.3 : width * 0.6;\n    svgWidth = width;\n    return {width, height};\n}\n\n/**\n * Generate a simulation, using the nodes and edges (links)\n * extracted from the dependencies between course modules.\n * The nodes are indexed by the course module id.\n * @param {{id, name, depend, predecessor}[]} dependencies\n * @returns {Object} d3 simulation object\n */\nfunction generateSimplifiedSimulation(dependencies) {\n    return d3.forceSimulation(dependencies)\n        .force('x0', d3.forceX())\n        .force('y0', d3.forceY())\n        .force('collide', d3.forceCollide().radius(20))\n        .force('charge', d3.forceManyBody().strength(-300))\n        .force('link', d3.forceLink(computeEdgesSimplifiedDependencies(dependencies)).distance(200).id(d => d.id));\n}\n\n/**\n * Generate a simulation, using the nodes and edges (links)\n * extracted from the dependencies between course modules.\n * The activity nodes are indexed by the course module id,\n * the operator nodes are indexed by a generated unique id.\n * @param {{id, name, depend, predecessor}[]} dependencies\n * @returns {Object} d3 simulation object\n */\nfunction generateFullSimulation(dependencies) {\n    let {edges, nodes} = computeEdgesAndNodesFullDependencies(dependencies);\n    return d3.forceSimulation(nodes)\n        .force('x0', d3.forceX())\n        .force('y0', d3.forceY())\n        .force('isSource', d3.forceX(-svgWidth / 3).strength(n => n.isSource))\n        .force('isTarget', d3.forceX(svgWidth / 3).strength(n => n.isTarget))\n        .force('collide', d3.forceCollide(100).radius(n => (n.genus === 'activity' ? fullNodeRadius : operatorRadius) + 30))\n        .force('charge', d3.forceManyBody().strength(-300))\n        .force('link', d3.forceLink(edges).distance(50).id(d => d.id));\n}\n\n/**\n * For a simplified representation, flatten any nesting.\n * @param {{id, name, depend, predecessor}[]} dependencies\n * @return {Object[]}\n */\nfunction computeEdgesSimplifiedDependencies(dependencies) {\n    // For an array of nested dependencies\n    // extract all the cm.id of leaves of type 'completion'\n    let leaves = (depend => // TODO fix small bug here d.op && !d.type\n        depend.c.flatMap(d => d.op ? leaves(d) : (d.type === 'completion' ? d.cm : [])));\n    return dependencies\n        .filter(({depend}) => (depend !== null))\n        .map(({id, name, depend, predecessor}) =>\n            leaves(depend).map(cm => {\n                return {\n                    target: id,\n                    source: cm === -1 ? predecessor : cm,\n                    name: name\n                };\n            }))\n        .flat();\n}\n\n/**\n * For a full representation we need nodes for the operators besides the nodes\n * representing the activities. For each node we use fields id, name, genus (activity or operator),\n * isSource and isTarget (the last two are for the layout - sort of extenden fuzzy logic,\n * they are a quantity instead of a boolean).\n * An activity node has as id its course module id and as name its name.\n * An operator node has as id the a uniquely generated id.\n *\n * For each completion of an activity there is a flag 'e' which\n * can have value 0, 1, 2 or 3 (meaning: activity (0) should not be completed; (1) must be completed;\n * (2) must be completed an passed; (3) must be completed and failed).\n * TODO Add a node with that flag between the activity and the previous node.\n * @param {{id, name, depend, predecessor}[]} dependencies\n * @return {{edges: Object[], nodes: Object[]}}\n */\nfunction computeEdgesAndNodesFullDependencies(dependencies) {\n\n    let onlyNonCompletionConditionsIn = function(dependList) {\n        return dependList.filter(c => (c.type && c.type == 'completion' || (!c.type && c.op))).length === 0;\n    };\n\n    let uid = 0;\n\n    let getNextUID = function() {\n        return 'uid_' + uid++;\n    };\n\n    let extractActivityNodes = function(dependencies) {\n        return dependencies.map(d => {\n            return {\n                id: d.id,\n                name: d.name,\n                genus: 'activity',\n                isSource: 0,\n                isTarget: 0,\n            };\n        });\n    };\n\n    let edges = [];\n    let nodes = extractActivityNodes(dependencies);\n\n    // 'id' is the id field of the target node, of genus 'operator' after the first call.\n    // toGenus: genus of the target node ('activity' or 'operator')\n    // dependList the list of dependencies that have the node with id id as target\n    // predecessor is the cmid of the activity node for which we are extracting the information,\n    // to be used if in the nesting of dependencies there will be one with {type: 'completion', cm:-1}\n    // An edge has the same genus as its target.\n    let extractEdgesAndNodes = function(id, toGenus, dependList, predecessor) {\n        dependList.forEach(el => {\n            if (!el.type && el.op && !onlyNonCompletionConditionsIn(el.c)) {\n                // Generate node\n                let newNode = {\n                    id: getNextUID(),\n                    name: el.op,\n                    genus: 'operator',\n                    isTarget: 0.1,\n                    isSource: 0.1\n                };\n                nodes.push(newNode);\n                // Generate edge\n                let newEdge = {\n                    target: id,\n                    source: newNode.id,\n                    toGenus: toGenus\n                };\n                edges.push(newEdge);\n                // Recursive call\n                extractEdgesAndNodes(newNode.id, 'operator', el.c, predecessor);\n            } else if (el.type === 'completion' && el.e > 0) {\n                // Generate edge\n                let newEdge = {\n                    target: id,\n                    source: el.cm === -1 ? predecessor : el.cm,\n                    toGenus: toGenus\n                };\n                // Increase isSource of the source node to a max of 1.5\n                let sn = nodes.find(n => n.id === newEdge.source);\n                sn.isSource = (sn.isSource + 0.6 > 1.5 ? 1.5 : sn.isSource + 0.6);\n                edges.push(newEdge);\n            } else if (el.type === 'completion' && el.e === 0) {\n                // Connect with two edges a 'not' node in between\n                let newNode = {\n                    id: getNextUID(),\n                    name: 'not',\n                    genus: 'operator',\n                    isTarget: 0.1,\n                    isSource: 0.1\n                };\n                let newEdgeFromNot = {\n                    target: id,\n                    source: newNode.id,\n                    toGenus: toGenus\n                };\n                let newEdgeToNot = {\n                    target: newNode.id,\n                    source: el.cm === -1 ? predecessor : el.cm,\n                    toGenus: 'operator'\n                };\n                nodes.push(newNode);\n                edges.push(newEdgeFromNot);\n                edges.push(newEdgeToNot);\n                // Increase isSource of the source node to a max of 1.5\n                let sn = nodes.find(n => n.id === newEdgeToNot.source);\n                sn.isSource = (sn.isSource + 0.6 > 1.5 ? 1.5 : sn.isSource + 0.6);\n            }\n        });\n    };\n\n    dependencies.forEach(a => {\n        if (a.depend !== null) {\n            // If an activity has some availability conditions, set the value for isTarget in its node.\n            // For the moment I am not checking if the conditions are of the wrong type\n            nodes.find(n => n.id === a.id).isTarget = 0.9;\n            extractEdgesAndNodes(a.id, 'activity', [a.depend], a.predecessor);\n        }\n    });\n\n    return {edges, nodes};\n}\n\n/**\n * Use d3 to display nodes and edges (links).\n * @param {Object} simulation - d3 simulation object\n */\nfunction displaySimplifiedGraph(simulation) {\n    displaySimplifiedEdges(simulation.force('link').links());\n    displaySimplifiedNodesAndLabels(simulation.nodes());\n}\n\n/**\n * Add the graphical elements to display the edges.\n * @param {Object[]} sEdges - Edges (links) in the d3 simulation.\n */\n function displaySimplifiedEdges(sEdges) {\n    d3.select('g.availdep').append('g').selectAll('line').data(sEdges)\n        .enter().append('line')\n        .attr('stroke', arrowColour)\n        .attr('stroke-width', arrowWidth + 'px')\n        .attr(\"stroke-linecap\", \"round\")\n        .attr('marker-end', 'url(#arrow)');\n}\n\n/**\n * Use d3 to display nodes and edges (links).\n * @param {Object} simulation - d3 simulation object\n */\n function displayFullGraph(simulation) {\n    displayFullEdges(simulation.force('link').links());\n    displayFullNodesAndLabels(simulation.nodes());\n}\n\n/**\n * Add the graphical elements to display the edges.\n * @param {Object[]} sEdges - Edges (links) in the d3 simulation.\n */\nfunction displayFullEdges(sEdges) {\n    d3.select('g.availdep').append('g').selectAll('line').data(sEdges)\n        .enter().append('line')\n        .attr('stroke', textColour)\n        .attr('stroke-opacity', 0.7)\n        .attr('stroke-width', arrowWidth + 'px')\n        .attr(\"stroke-linecap\", \"round\")\n        .attr('marker-end', e => e.toGenus === 'activity' ?\n            'url(#arrowToActivity' :\n            'url(#arrowToOperator');\n}\n\n/**\n * Add the graphical elements to display the nodes and labels.\n * @param {Object[]} sNodes - Nodes in the d3 simulation.\n */\n function displaySimplifiedNodesAndLabels(sNodes) {\n    d3.select('g.availdep').append('g').selectAll('circle').data(sNodes)\n        .join('circle')\n        .attr('fill', nodeColour)\n        .attr('stroke', 'white')\n        .attr('r', 16);\n    d3.select('g.availdep').append('g').selectAll('text').data(sNodes)\n        .join('text')\n        .attr('fill', textColour)\n        .attr('font-family', 'sans-serif')\n        .attr('font-weight', 'bold')\n      .clone().lower()\n        .attr('stroke', 'white')\n        .attr('stroke-width', 4)\n        .attr('stroke-opacity', 0.5);\n}\n\n/**\n * Add the graphical elements to display the nodes and labels.\n * @param {Object[]} sNodes - Nodes in the d3 simulation.\n */\n function displayFullNodesAndLabels(sNodes) {\n    d3.select('g.availdep').append('g').selectAll('circle').data(sNodes)\n        .join('circle')\n        .attr('fill', n => n.genus === 'activity' ? nodeColour\n            : n.name === '&' ? andColour\n            : n.name === '|' ? orColour\n            : n.name === '!&' ? notAndColour\n            : n.name === '!|' ? notOrColour\n            : n.name === 'not' ? notColour\n            : otherOperatorColour)\n        .attr('stroke', 'white')\n        .attr('stroke-width', 3)\n        .attr('r', n => n.genus === 'activity' ? fullNodeRadius : operatorRadius);\n    d3.select('g.availdep').append('g').selectAll('text').data(sNodes)\n        .join('text')\n        .attr('fill', textColour)\n        .attr('font-family', 'sans-serif')\n        .attr('font-weight', 'bold')\n        .attr('text-anchor', 'middle')\n        .attr('dx', -5)\n        .attr('dominant-baseline', 'middle')\n        .attr('dy', 5)\n        .attr('filter', 'url(#textShadow)');\n}\n\nlet edges, nodes, labels;\n\n/**\n * Save the graphical representation of edges, nodes and labals.\n */\nfunction rememberD3Selections() {\n    edges = d3.select('g.availdep').selectAll('line');\n    nodes = d3.select('g.availdep').selectAll('circle');\n    labels = d3.select('g.availdep').selectAll('text');\n}\n\n/**\n * Update the simulation.\n */\nfunction tick() {\n    nodes\n        .attr('cx', n => n.x)\n        .attr('cy', n => n.y);\n    edges\n        .attr('x1', e => e.source.x)\n        .attr('y1', e => e.source.y)\n        .attr('x2', e => e.target.x)\n        .attr('y2', e => e.target.y);\n    labels\n        .attr('x', n => n.x + 5)\n        .attr('y', n => n.y - 5)\n        .text(n => n.name);\n\n}\n\n/**\n * Make nodes draggable.\n * Once dragged a node is fixed to its assigned position in the simulation.\n * @param {Object} simulation - d3 simulation object\n */\nfunction makeDraggable(simulation) {\n    nodes\n        .call(d3.drag()\n        .on('start', (event, n) => {\n            if (!event.active) {\n                simulation.alphaTarget(0.3).restart();\n            }\n            n.fx = event.x;\n            n.fy = event.y;\n        })\n        .on('drag',\n            (event, n) => {\n                n.fx = event.x;\n                n.fy = event.y;\n            })\n        .on('end', (event) => {\n            if (!event.active) {\n                simulation.alphaTarget(0);\n            }\n        })\n        );\n}\n\n/**\n * Add callback for click event to each node.\n */\nfunction makeDoubleClickable() {\n    nodes.on('click', highlightDependencies);\n}\n\n/**\n * Stores ancestors of each node as an additional property.\n * We need this for the highlight function.\n * @param {Object[]} allEdges\n * @returns {Object[]}\n */\nfunction storeAncestorEdgesAndNodesInAllNodes(allEdges) {\n    return nodes.data().forEach(n => computeAndStoreAncestorEdgesAndNodes(n, allEdges));\n}\n\n/**\n * Compute the ancestor edges and nodes for a given node and stores then in an\n * additional property 'ancestors' of the node.\n * Even if it would be logically absurd to build a cycle in the directed graph of dependencies,\n * there is no guarantee that this does not happen. Moreover a cycle per se does not mean that\n * some activites are unreachable, since they can be negated.\n * @param {Object} node a d3 (circle) node from a simulation\n * @param {Object[]} allEdges\n */\nfunction computeAndStoreAncestorEdgesAndNodes(node, allEdges) {\n    let aNodes = new Set();\n    let aEdges = new Set();\n    let toBeExaminedNodes = [node];\n    while (toBeExaminedNodes.length) {\n        // Each time one element of the queue of nodes to be examined is moved to the set aNodes\n        let currentNode = toBeExaminedNodes.shift();\n        aNodes.add(currentNode);\n        // Iterate over the edges and look for the ones that have the current node as target\n        allEdges.data().forEach(ed => {\n            if (ed.target.id === currentNode.id) {\n                aEdges.add(ed);\n                if (!aNodes.has(ed.source)) {\n                    toBeExaminedNodes.push(ed.source);\n                }\n            }\n        });\n    }\n    node.ancestors = [...aNodes].concat([...aEdges]);\n}\n\n/**\n * Check if an edge is ancestor of node\n * @param {*} edgeOrNode the edge or node to check\n * @param {*} node\n * @return {Object[]} the list of ancestor nodes\n */\nfunction isAncestor(edgeOrNode, node) {\n    return node.ancestors.includes(edgeOrNode);\n}\n\n/**\n * Toggle highlight function. The opacity of all nodes that are not\n * ancestory of a given node is reduced or set back to normal.\n */\nfunction highlightDependencies() {\n    if (toggleHighlight === 0) {\n        // Reduce the opacity of all but the ancestor nodes\n        let d = d3.select(this).data()[0];\n        nodes.style(\"opacity\", function(o) {\n            return isAncestor(o, d) ? 1 : 0.1;\n        });\n        edges.style(\"opacity\", function(o) {\n            return isAncestor(o, d) ? 1 : 0.1;\n        });\n        // Mark hightlighting as on\n        toggleHighlight = 1;\n    } else {\n        // Put opacity back to 1 for all nodes and links\n        nodes.style(\"opacity\", 1);\n        edges.style(\"opacity\", 1);\n        // Mark highlighting as off\n        toggleHighlight = 0;\n    }\n}\n\n/* eslint-enable no-nested-ternary */\n"],"names":["full","courseid","fullparam","Ajax","call","methodname","args","then","dependencies","width","orientation","simulation","allEdges","dimensions","d3","select","attr","height","dev","append","setupSvg","document","querySelector","parentNode","clientWidth","screen","_screen$orientation","type","svgWidth","forEach","d","depend","JSON","parse","forceSimulation","force","forceX","forceY","forceCollide","radius","forceManyBody","strength","forceLink","leaves","c","flatMap","op","cm","filter","map","id","name","predecessor","target","source","flat","computeEdgesSimplifiedDependencies","distance","generateSimplifiedSimulation","sEdges","links","selectAll","data","enter","arrowWidth","sNodes","nodes","join","clone","lower","displaySimplifiedGraph","onlyNonCompletionConditionsIn","dependList","length","uid","getNextUID","extractActivityNodes","genus","isSource","isTarget","edges","extractEdgesAndNodes","toGenus","el","e","newEdge","sn","find","n","push","newNode","newEdgeFromNot","newEdgeToNot","a","computeEdgesAndNodesFullDependencies","generateFullSimulation","displayFullGraph","labels","node","aNodes","Set","aEdges","toBeExaminedNodes","currentNode","shift","add","ed","has","ancestors","_toConsumableArray","concat","computeAndStoreAncestorEdgesAndNodes","on","tick","drag","event","active","alphaTarget","restart","fx","x","fy","y","makeDraggable","highlightDependencies","catch","toggleHighlight","text","isAncestor","edgeOrNode","includes","this","style","o"],"mappings":"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"}
{"version":3,"file":"visualiseDependencies.min.js","sources":["../src/visualiseDependencies.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Visualise dependencies.\n *\n * @copyright  2022 Paola Maneggia, Mathias Kegelmann\n * @author     Paola Maneggia <paola.maneggia@gmail.com>, Mathias Kegelmann <mathias.kegelmann@gmail.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n * @module     block/availdep\n */\n\n/* global d3 */\n\nimport Ajax from 'core/ajax';\n\nlet full = 'no';\n\nexport const init = (courseid, fullparam) => {\n    full = fullparam;\n    var promises = Ajax.call([{\n        methodname: 'block_availdep_fetch_course_modules_with_names_and_dependencies',\n        args: {courseid: courseid}\n    }\n]);\n\n/* eslint-disable promise/always-return */\npromises[0]\n    .then(dependencies => {\n        let dimensions = determineSvgSize();\n        setupSvg(dimensions);\n        dependencies.forEach(d => {\n            d.depend = JSON.parse(d.depend);\n        });\n        let simulation;\n        if (full === 'no') {\n            simulation = generateSimplifiedSimulation(dependencies);\n            displaySimplifiedGraph(simulation);\n        } else {\n            simulation = generateFullSimulation(dependencies);\n            displayFullGraph(simulation);\n        }\n        rememberD3Selections();\n        storeAncestorEdgesAndNodesInAllNodes(edges);\n        simulation.on('tick', tick);\n        makeDraggable(simulation);\n        makeDoubleClickable(simulation);\n    }).catch();\n};\n/* eslint-enable promise/always-return */\n\nlet toggleHighlight = 0;\n\nlet nodeColour = '#AEDAEA';\nlet textColour = '#364958';\nlet arrowColour = '#516E84';\nlet andColour = '#FFB400';\nlet orColour = '#CEFF1A';\nlet notAndColour = '#F9CFF2';\nlet notOrColour = '#D1FAFF';\nlet otherOperatorColour = '#D1FAFF';\nlet notColour = '#EA7B5D';\n\nlet fullNodeRadius = 50;\nlet operatorRadius = 20;\n\nlet arrowWidth = 2;\n\nlet svgWidth;\n\n/**\n * Set width, height and viewBox of the svg element of class 'availdep'.\n * @param {Object} dimensions\n * @param {number} dimensions.width\n * @param {number} dimensions.height\n */\nfunction setupSvg(dimensions) {\n    d3.select('svg.availdep')\n        .attr('width', dimensions.width)\n        .attr('height', dimensions.height)\n        .attr('viewBox', -dimensions.width / 2 + ' ' + -dimensions.height / 2\n            + ' ' + dimensions.width + ' ' + dimensions.height);\n    addMarker();\n    addFilterDropShadow();\n}\n\n/**\n * Add marker elements to display arrows.\n */\nfunction addMarker() {\n    let dev = d3.select('g.availdep').append('defs');\n    dev.append('marker')\n      .attr('id', 'arrow')\n      .attr('viewBox', \"0 0 10 10\")\n      .attr('refX', 23)\n      .attr('refY', 5)\n      .attr('markerUnits', 'strokeWidth')\n      .attr('markerWidth', 6)\n      .attr('markerHeight', 8)\n      .attr('orient', 'auto')\n    .append('path')\n      .attr('fill', arrowColour)\n      .attr('d', 'M 0 0 L 10 5 L 0 10 z');\n\n    dev.append('marker')\n      .attr('id', 'arrowToActivity')\n      .attr('viewBox', \"0 0 10 10\")\n      .attr('refX', 52)\n      .attr('refY', 5)\n      .attr('markerUnits', 'strokeWidth')\n      .attr('markerWidth', 6)\n      .attr('markerHeight', 8)\n      .attr('orient', 'auto')\n    .append('path')\n      .attr('fill', arrowColour)\n      .attr('d', 'M 0 0 L 10 5 L 0 10 z');\n\n    dev.append('marker')\n      .attr('id', 'arrowToOperator')\n      .attr('viewBox', \"0 0 10 10\")\n      .attr('refX', 27)\n      .attr('refY', 5)\n      .attr('markerUnits', 'strokeWidth')\n      .attr('markerWidth', 6)\n      .attr('markerHeight', 8)\n      .attr('orient', 'auto')\n    .append('path')\n      .attr('fill', arrowColour)\n      .attr('d', 'M 0 0 L 10 5 L 0 10 z');\n}\n\n/**\n * Add feDropShadow to improve contrast.\n */\nfunction addFilterDropShadow() {\n    let dev = d3.select('g.availdep defs');\n    dev.append('filter')\n      .attr('id', 'textShadow')\n    .append('feDropShadow')\n      .attr('dx', 0)\n      .attr('dy', 0)\n      .attr('stdDeviation', 2)\n      .attr('flood-color', 'white')\n      .attr('flood-opacity', 1);\n}\n\n/**\n * Compute the width and height for the svg of class 'availdep'\n * element reading the ones of the parent.\n * @returns {{width: number, height: number}}\n */\nfunction determineSvgSize() {\n    let svg = document.querySelector('svg.availdep');\n    let width = svg.parentNode.clientWidth;\n    let orientation = screen.orientation?.type;\n    let height = orientation === \"portrait-primary\" ? width * 1.3 : width * 0.6;\n    svgWidth = width;\n    return {width, height};\n}\n\n/**\n * Generate a simulation, using the nodes and edges (links)\n * extracted from the dependencies between course modules.\n * The nodes are indexed by the course module id.\n * @param {{id, name, depend, predecessor}[]} dependencies\n * @returns {Object} d3 simulation object\n */\nfunction generateSimplifiedSimulation(dependencies) {\n    return d3.forceSimulation(dependencies)\n        .force('x0', d3.forceX())\n        .force('y0', d3.forceY())\n        .force('collide', d3.forceCollide().radius(20))\n        .force('charge', d3.forceManyBody().strength(-300))\n        .force('link', d3.forceLink(computeEdgesSimplifiedDependencies(dependencies)).distance(200).id(d => d.id));\n}\n\n/**\n * Generate a simulation, using the nodes and edges (links)\n * extracted from the dependencies between course modules.\n * The activity nodes are indexed by the course module id,\n * the operator nodes are indexed by a generated unique id.\n * @param {{id, name, depend, predecessor}[]} dependencies\n * @returns {Object} d3 simulation object\n */\nfunction generateFullSimulation(dependencies) {\n    let {edges, nodes} = computeEdgesAndNodesFullDependencies(dependencies);\n    return d3.forceSimulation(nodes)\n        .force('x0', d3.forceX())\n        .force('y0', d3.forceY())\n        .force('isSource', d3.forceX(-svgWidth / 3).strength(n => n.isSource))\n        .force('isTarget', d3.forceX(svgWidth / 3).strength(n => n.isTarget))\n        .force('collide', d3.forceCollide(100).radius(n => (n.genus === 'activity' ? fullNodeRadius : operatorRadius) + 30))\n        .force('charge', d3.forceManyBody().strength(-300))\n        .force('link', d3.forceLink(edges).distance(50).id(d => d.id));\n}\n\n/**\n * For a simplified representation, flatten any nesting.\n * @param {{id, name, depend, predecessor}[]} dependencies\n * @return {Object[]}\n */\nfunction computeEdgesSimplifiedDependencies(dependencies) {\n    // For an array of nested dependencies\n    // extract all the cm.id of leaves of type 'completion'\n    let leaves = (depend => // TODO fix small bug here d.op && !d.type\n        depend.c.flatMap(d => d.op ? leaves(d) : (d.type === 'completion' ? d.cm : [])));\n    return dependencies\n        .filter(({depend}) => (depend !== null))\n        .map(({id, name, depend, predecessor}) =>\n            leaves(depend).map(cm => {\n                return {\n                    target: id,\n                    source: cm === -1 ? predecessor : cm,\n                    name: name\n                };\n            }))\n        .flat();\n}\n\n/**\n * For a full representation we need nodes for the operators besides the nodes\n * representing the activities. For each node we use fields id, name, genus (activity or operator),\n * isSource and isTarget (the last two are for the layout - sort of extenden fuzzy logic,\n * they are a quantity instead of a boolean).\n * An activity node has as id its course module id and as name its name.\n * An operator node has as id the a uniquely generated id.\n *\n * For each completion of an activity there is a flag 'e' which\n * can have value 0, 1, 2 or 3 (meaning: activity (0) should not be completed; (1) must be completed;\n * (2) must be completed an passed; (3) must be completed and failed).\n * TODO Add a node with that flag between the activity and the previous node.\n * @param {{id, name, depend, predecessor}[]} dependencies\n * @return {{edges: Object[], nodes: Object[]}}\n */\nfunction computeEdgesAndNodesFullDependencies(dependencies) {\n\n    let onlyNonCompletionConditionsIn = function(dependList) {\n        return dependList.filter(c => (c.type && c.type == 'completion' || (!c.type && c.op))).length === 0;\n    };\n\n    let uid = 0;\n\n    let getNextUID = function() {\n        return 'uid_' + uid++;\n    };\n\n    let extractActivityNodes = function(dependencies) {\n        return dependencies.map(d => {\n            return {\n                id: d.id,\n                name: d.name,\n                genus: 'activity',\n                isSource: 0,\n                isTarget: 0,\n            };\n        });\n    };\n\n    let edges = [];\n    let nodes = extractActivityNodes(dependencies);\n\n    // 'id' is the id field of the target node, of genus 'operator' after the first call.\n    // toGenus: genus of the target node ('activity' or 'operator')\n    // dependList the list of dependencies that have the node with id id as target\n    // predecessor is the cmid of the activity node for which we are extracting the information,\n    // to be used if in the nesting of dependencies there will be one with {type: 'completion', cm:-1}\n    // An edge has the same genus as its target.\n    let extractEdgesAndNodes = function(id, toGenus, dependList, predecessor) {\n        dependList.forEach(el => {\n            if (!el.type && el.op && !onlyNonCompletionConditionsIn(el.c)) {\n                // Generate node\n                let newNode = {\n                    id: getNextUID(),\n                    name: el.op,\n                    genus: 'operator',\n                    isTarget: 0.1,\n                    isSource: 0.1\n                };\n                nodes.push(newNode);\n                // Generate edge\n                let newEdge = {\n                    target: id,\n                    source: newNode.id,\n                    toGenus: toGenus\n                };\n                edges.push(newEdge);\n                // Recursive call\n                extractEdgesAndNodes(newNode.id, 'operator', el.c, predecessor);\n            } else if (el.type === 'completion' && el.e > 0) {\n                // Generate edge\n                let newEdge = {\n                    target: id,\n                    source: el.cm === -1 ? predecessor : el.cm,\n                    toGenus: toGenus\n                };\n                // Increase isSource of the source node to a max of 1.5\n                let sn = nodes.find(n => n.id === newEdge.source);\n                sn.isSource = (sn.isSource + 0.6 > 1.5 ? 1.5 : sn.isSource + 0.6);\n                edges.push(newEdge);\n            } else if (el.type === 'completion' && el.e === 0) {\n                // Connect with two edges a 'not' node in between\n                let newNode = {\n                    id: getNextUID(),\n                    name: 'not',\n                    genus: 'operator',\n                    isTarget: 0.1,\n                    isSource: 0.1\n                };\n                let newEdgeFromNot = {\n                    target: id,\n                    source: newNode.id,\n                    toGenus: toGenus\n                };\n                let newEdgeToNot = {\n                    target: newNode.id,\n                    source: el.cm === -1 ? predecessor : el.cm,\n                    toGenus: 'operator'\n                };\n                nodes.push(newNode);\n                edges.push(newEdgeFromNot);\n                edges.push(newEdgeToNot);\n                // Increase isSource of the source node to a max of 1.5\n                let sn = nodes.find(n => n.id === newEdgeToNot.source);\n                sn.isSource = (sn.isSource + 0.6 > 1.5 ? 1.5 : sn.isSource + 0.6);\n            }\n        });\n    };\n\n    dependencies.forEach(a => {\n        if (a.depend !== null) {\n            // If an activity has some availability conditions, set the value for isTarget in its node.\n            // For the moment I am not checking if the conditions are of the wrong type\n            nodes.find(n => n.id === a.id).isTarget = 0.9;\n            extractEdgesAndNodes(a.id, 'activity', [a.depend], a.predecessor);\n        }\n    });\n\n    return {edges, nodes};\n}\n\n/**\n * Use d3 to display nodes and edges (links).\n * @param {Object} simulation - d3 simulation object\n */\nfunction displaySimplifiedGraph(simulation) {\n    displaySimplifiedEdges(simulation.force('link').links());\n    displaySimplifiedNodesAndLabels(simulation.nodes());\n}\n\n/**\n * Add the graphical elements to display the edges.\n * @param {Object[]} sEdges - Edges (links) in the d3 simulation.\n */\n function displaySimplifiedEdges(sEdges) {\n    d3.select('g.availdep').append('g').selectAll('line').data(sEdges)\n        .enter().append('line')\n        .attr('stroke', arrowColour)\n        .attr('stroke-width', arrowWidth + 'px')\n        .attr(\"stroke-linecap\", \"round\")\n        .attr('marker-end', 'url(#arrow)');\n}\n\n/**\n * Use d3 to display nodes and edges (links).\n * @param {Object} simulation - d3 simulation object\n */\n function displayFullGraph(simulation) {\n    displayFullEdges(simulation.force('link').links());\n    displayFullNodesAndLabels(simulation.nodes());\n}\n\n/**\n * Add the graphical elements to display the edges.\n * @param {Object[]} sEdges - Edges (links) in the d3 simulation.\n */\nfunction displayFullEdges(sEdges) {\n    d3.select('g.availdep').append('g').selectAll('line').data(sEdges)\n        .enter().append('line')\n        .attr('stroke', textColour)\n        .attr('stroke-opacity', 0.7)\n        .attr('stroke-width', arrowWidth + 'px')\n        .attr(\"stroke-linecap\", \"round\")\n        .attr('marker-end', e => e.toGenus === 'activity' ?\n            'url(#arrowToActivity' :\n            'url(#arrowToOperator');\n}\n\n/**\n * Add the graphical elements to display the nodes and labels.\n * @param {Object[]} sNodes - Nodes in the d3 simulation.\n */\n function displaySimplifiedNodesAndLabels(sNodes) {\n    d3.select('g.availdep').append('g').selectAll('circle').data(sNodes)\n        .join('circle')\n        .attr('fill', nodeColour)\n        .attr('stroke', 'white')\n        .attr('r', 16);\n    d3.select('g.availdep').append('g').selectAll('text').data(sNodes)\n        .join('text')\n        .attr('fill', textColour)\n        .attr('font-family', 'sans-serif')\n        .attr('font-weight', 'bold')\n      .clone().lower()\n        .attr('stroke', 'white')\n        .attr('stroke-width', 4)\n        .attr('stroke-opacity', 0.5);\n}\n\n/**\n * Add the graphical elements to display the nodes and labels.\n * @param {Object[]} sNodes - Nodes in the d3 simulation.\n */\n function displayFullNodesAndLabels(sNodes) {\n    d3.select('g.availdep').append('g').selectAll('circle').data(sNodes)\n        .join('circle')\n        .attr('fill', n => n.genus === 'activity' ? nodeColour\n            : n.name === '&' ? andColour\n            : n.name === '|' ? orColour\n            : n.name === '!&' ? notAndColour\n            : n.name === '!|' ? notOrColour\n            : n.name === 'not' ? notColour\n            : otherOperatorColour)\n        .attr('stroke', 'white')\n        .attr('stroke-width', 3)\n        .attr('r', n => n.genus === 'activity' ? fullNodeRadius : operatorRadius);\n    d3.select('g.availdep').append('g').selectAll('text').data(sNodes)\n        .join('text')\n        .attr('fill', textColour)\n        .attr('font-family', 'sans-serif')\n        .attr('font-weight', 'bold')\n        .attr('text-anchor', 'middle')\n        .attr('dx', -5)\n        .attr('dominant-baseline', 'middle')\n        .attr('dy', 5)\n        .attr('filter', 'url(#textShadow)');\n}\n\nlet edges, nodes, labels;\n\n/**\n * Save the graphical representation of edges, nodes and labals.\n */\nfunction rememberD3Selections() {\n    edges = d3.select('g.availdep').selectAll('line');\n    nodes = d3.select('g.availdep').selectAll('circle');\n    labels = d3.select('g.availdep').selectAll('text');\n}\n\n/**\n * Update the simulation.\n */\nfunction tick() {\n    nodes\n        .attr('cx', n => n.x)\n        .attr('cy', n => n.y);\n    edges\n        .attr('x1', e => e.source.x)\n        .attr('y1', e => e.source.y)\n        .attr('x2', e => e.target.x)\n        .attr('y2', e => e.target.y);\n    labels\n        .attr('x', n => n.x + 5)\n        .attr('y', n => n.y - 5)\n        .text(n => n.name);\n\n}\n\n/**\n * Make nodes draggable.\n * Once dragged a node is fixed to its assigned position in the simulation.\n * @param {Object} simulation - d3 simulation object\n */\nfunction makeDraggable(simulation) {\n    nodes\n        .call(d3.drag()\n        .on('start', (event, n) => {\n            if (!event.active) {\n                simulation.alphaTarget(0.3).restart();\n            }\n            n.fx = event.x;\n            n.fy = event.y;\n        })\n        .on('drag',\n            (event, n) => {\n                n.fx = event.x;\n                n.fy = event.y;\n            })\n        .on('end', (event) => {\n            if (!event.active) {\n                simulation.alphaTarget(0);\n            }\n        })\n        );\n}\n\n/**\n * Add callback for click event to each node.\n */\nfunction makeDoubleClickable() {\n    nodes.on('click', highlightDependencies);\n}\n\n/**\n * Stores ancestors of each node as an additional property.\n * We need this for the highlight function.\n * @param {Object[]} allEdges\n * @returns {Object[]}\n */\nfunction storeAncestorEdgesAndNodesInAllNodes(allEdges) {\n    return nodes.data().forEach(n => computeAndStoreAncestorEdgesAndNodes(n, allEdges));\n}\n\n/**\n * Compute the ancestor edges and nodes for a given node and stores then in an\n * additional property 'ancestors' of the node.\n * Even if it would be logically absurd to build a cycle in the directed graph of dependencies,\n * there is no guarantee that this does not happen. Moreover a cycle per se does not mean that\n * some activites are unreachable, since they can be negated.\n * @param {Object} node a d3 (circle) node from a simulation\n * @param {Object[]} allEdges\n */\nfunction computeAndStoreAncestorEdgesAndNodes(node, allEdges) {\n    let aNodes = new Set();\n    let aEdges = new Set();\n    let toBeExaminedNodes = [node];\n    while (toBeExaminedNodes.length) {\n        // Each time one element of the queue of nodes to be examined is moved to the set aNodes\n        let currentNode = toBeExaminedNodes.shift();\n        aNodes.add(currentNode);\n        // Iterate over the edges and look for the ones that have the current node as target\n        allEdges.data().forEach(ed => {\n            if (ed.target.id === currentNode.id) {\n                aEdges.add(ed);\n                if (!aNodes.has(ed.source)) {\n                    toBeExaminedNodes.push(ed.source);\n                }\n            }\n        });\n    }\n    node.ancestors = [...aNodes].concat([...aEdges]);\n}\n\n/**\n * Check if an edge is ancestor of node\n * @param {*} edgeOrNode the edge or node to check\n * @param {*} node\n * @return {Object[]} the list of ancestor nodes\n */\nfunction isAncestor(edgeOrNode, node) {\n    return node.ancestors.includes(edgeOrNode);\n}\n\n/**\n * Toggle highlight function. The opacity of all nodes that are not\n * ancestory of a given node is reduced or set back to normal.\n */\nfunction highlightDependencies() {\n    if (toggleHighlight === 0) {\n        // Reduce the opacity of all but the ancestor nodes\n        let d = d3.select(this).data()[0];\n        nodes.style(\"opacity\", function(o) {\n            return isAncestor(o, d) ? 1 : 0.1;\n        });\n        edges.style(\"opacity\", function(o) {\n            return isAncestor(o, d) ? 1 : 0.1;\n        });\n        // Mark hightlighting as on\n        toggleHighlight = 1;\n    } else {\n        // Put opacity back to 1 for all nodes and links\n        nodes.style(\"opacity\", 1);\n        edges.style(\"opacity\", 1);\n        // Mark highlighting as off\n        toggleHighlight = 0;\n    }\n}\n"],"names":["full","courseid","fullparam","Ajax","call","methodname","args","then","dependencies","simulation","allEdges","dimensions","d3","select","attr","width","height","dev","append","addMarker","setupSvg","document","querySelector","parentNode","clientWidth","orientation","screen","_screen$orientation","type","svgWidth","determineSvgSize","forEach","d","depend","JSON","parse","forceSimulation","force","forceX","forceY","forceCollide","radius","forceManyBody","strength","forceLink","leaves","c","flatMap","op","cm","filter","_ref","map","_ref2","id","name","predecessor","target","source","flat","computeEdgesSimplifiedDependencies","distance","generateSimplifiedSimulation","sEdges","links","selectAll","data","enter","arrowWidth","sNodes","nodes","join","clone","lower","displaySimplifiedGraph","edges","onlyNonCompletionConditionsIn","dependList","length","uid","getNextUID","extractActivityNodes","genus","isSource","isTarget","extractEdgesAndNodes","toGenus","el","e","newEdge","sn","find","n","push","newNode","newEdgeFromNot","newEdgeToNot","a","computeEdgesAndNodesFullDependencies","generateFullSimulation","displayFullGraph","labels","node","aNodes","Set","aEdges","toBeExaminedNodes","currentNode","shift","add","ed","has","ancestors","concat","computeAndStoreAncestorEdgesAndNodes","on","tick","drag","event","active","alphaTarget","restart","fx","x","fy","y","makeDraggable","highlightDependencies","catch","toggleHighlight","text","isAncestor","edgeOrNode","includes","this","style","o"],"mappings":"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"}
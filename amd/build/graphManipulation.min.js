define("block_availdep/graphManipulation",["exports"],(function(_exports){function computePredecessors(node){return node.depend.c.filter((x=>"completion"===x.type))}function handleDanglingReferencesInNode(depend,ids){if(depend.op){let danglingReferenceFound=!1;return depend.c.forEach((d=>{let found=handleDanglingReferencesInNode(d,ids);danglingReferenceFound||(danglingReferenceFound=found)})),danglingReferenceFound}return"completion"===depend.type&&!ids.includes(depend.cm)&&(depend.cm=-2,!0)}Object.defineProperty(_exports,"__esModule",{value:!0}),_exports.fixDanglingReferences=function(dependencies,missingString){const ids=dependencies.map((x=>x.id)).concat([-1]);let danglingReferenceFound=!1;dependencies.forEach((node=>{if(node.depend){let found=handleDanglingReferencesInNode(node.depend,ids);danglingReferenceFound||(danglingReferenceFound=found)}})),danglingReferenceFound&&dependencies.push({id:-2,name:missingString,depend:null,predecessor:null})},_exports.removeDisconnectedNodes=
/**
   * Module for functions that manipulate the graph.
   *
   * @copyright  2022 Paola Maneggia
   * @author     Paola Maneggia <paola.maneggia@gmail.com>
   * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
   * @module     block/availdep
   */
function(dependencies){let notIsolatedNodes=function(dependencies){let notIsolatedNodes=new Set;return dependencies.forEach((node=>{(function(node){return node.depend&&computePredecessors(node).length>0})(node)&&(notIsolatedNodes.add(node.id),function(node,notIsolatedNodes){computePredecessors(node).forEach((x=>notIsolatedNodes.add(-1===x.cm?x.predecessor:x.cm)))}(node,notIsolatedNodes))})),notIsolatedNodes}(dependencies);return dependencies.filter((n=>notIsolatedNodes.has(n.id)))}}));

//# sourceMappingURL=graphManipulation.min.js.map